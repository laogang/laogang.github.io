[TOC]

# 使用java8就是保护你作为java程序员的职业生涯

## 1.名词概要

### 1.1 核心新特性

```
Lambda（匿名函数）、流、默认方法
```

### 1.2 函数式编程

```
将代码传递给方法的功能（同时也能够返回代码并将其包含在数据结构中）还让我们能够使用一整套新技巧。
```

### 1.3 函数式编程范式的基石

```
没有共享的可变数据，将方法和函数即代码传递给其他方法的能力。
```

### 1.4 函数式编程引进的核心思想

```
将方法和Lamdba作为一等值，以及在没有可变共享状态时，函数或方法可以有效、安全的并行执行。
```

### 1.5 行为参数化

```
一个方法接受多个不同的行为作为参数，并在内部使用他们，完成不同行为的能力。
行为参数化可以让代码更好的适应不断变化的需求，减轻未来的工作量。
```

### 1.6 函数式接口

```
只定义了一个抽象方法的接口就是函数式接口，哪怕有很多默认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。
```

#### 1.6.1 函数描述符

```
函数式接口的抽象方法的签名称为函数描述符。 eg: Runnable的函数描述符是 () -> void
```

### 1.7 流与集合的区别

```
和迭代器类似，流只能遍历一次。
使用Collection接口需要用户去迭代（比如用for-each），这称为外部迭代。相反，Stream库使用内部迭代——它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出一个函数说要干什么就可以了。
```

### 1.8 使用流

```
流的使用一般包括三件事：
一个数据源（如集合）来执行一个查询；
一个中间操作链，形成一条流的流水线；
一个终端操作，执行流水线，并能生成结果。
```

#### 1.8.1 筛选和切片

```
用谓词筛选：
Stream 接口支持filter方法，该操作会接受一个谓词（一个返回boolean的函数）作为参数，并返回所有符合谓词的元素的流。

筛选各异的元素：
流还支持一个叫做distinct的方法，它会返回一个元素各异（根据流所生成元素的hashCode和equals方法实现）的流。

截短流：
流支持limit(n)操作，该方法会返回一个不超过给定长度的流。所需的长度作为参数传递给limit作为参数。如果六十有序的，则最多返回前n个元素。

跳过元素：
流还支持skip(n)操作，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流。

```

#### 1.8.2  映射

```
流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射程一个新的元素(使用映射异常，是因为它和转换类似，但其中的席位差别在于它是“创建一个新版本”而不是取“修改”)。

流的扁平化flatMap
使用flatMap方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。
有一个叫做Arrays.stream()的方法可以接受一个数组并产生一个流。
```

#### 1.8.3  查找和匹配

```
短路求值：
对流而言，某些操作(例如allMatch、anyMatch、noneMatch、findFirst、findAny)不用处理整个流就能得到结果。同样，limit也是一个短路操作。 它们可以把无限流变成有限流。

findFirst和findAny的区别：
findAny方法将返回当前流中的任意元素，对于同一列表多次调用findAny有可能会返回不同的值。使用findAny是为了更高效的性能。
findFirst方法返回当前流流中的第一个元素。有些流有一个出现顺序来指定流中项目出现的逻辑顺序（比如由List或排好序的数据列生成的流）。
何时使用findFirst和findAny
   为什么会同时有findFirsrt和findAny，答案是并行。找到第一个元素在并行上限制更多。如果你不关心返回的元素是哪个，请使用findAny，因为它在使用并行时现在较少。

```

#### 1.8.4  归约

```
将流中所有元素反复结合起来，得到一个值，比如一个Integer。这样的查询可以被归纳为归约操作（将流归纳成一个值）。用函数式编程语言的术语来说，这成为折叠(flod)，因为你可以将这个操作看成把一张长长的纸（你的流）反复折叠成一个小方块，而这就是折叠操作的结果。

元素求和：
int sum = numbers.stream.reduce(0,(a,b)-> a + b);
reduce 接收两个参数：
一个初始值，这里是0；
一个BinaryOperator<T>来将两个元素结合起来产生一个新值，这里我们用的是lambda(a,b) -> a + b 。

Optional<Integer> sum = numbers.stream().reduce((a,b) -> (a+b));
reduce 还有一个重载的变体，它不会接受初始值，但是会返回一个Optional对象。


最大值和最小值：
Optional<Integer> max = numbers.stream().reduce(Integer::max);
Optional<Integer> min = numbers.stream().reduce(Integer::min);

```

#### 1.8.5  数值流

```
IntStream,DoubleStream,LongStream分别将流中的元素特殊化为int，double，long，从而避免了暗含的装箱成本。
IntStream：
int calories = menu.stream().mapToInt(Dish::getCalories).sum();
IntStream intStream =  menu.stream().mapToInt(Dish::getCalories);
Stream<Integer> stream = intStream.boxed();
OptionalInt maxCaloties = menu.stream().mapToInt(Dish::getCalories).max();
```

###  1.9  “函数式”函数准则

```
    被称为“函数式”的函数或方法都只能修改本地变量。除此之外，它引用的对象都应该是不可修改的对象。通过这种规定，我们期望所有的字段都为final类型，所有的引用类型字段都指向不可变对象。
    被称为“函数式”，函数或者方法不应该抛出任何异常。关于这一点，有一个极为简单而又极为教条的解释：你不应该抛出异常，因为一旦抛出异常，就意味着结果被终止了；不再像我们之前讨论的黑盒模式那样，由return返回一个恰当的结果值。

```

